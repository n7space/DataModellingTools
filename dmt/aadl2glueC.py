#!/usr/bin/env python3
# vim: set expandtab ts=8 sts=4 shiftwidth=4

# (C) Semantix Information Technologies, Neuropublic, and European Space Agency
#
# Licensed under the GPL with Runtime Exception.
# Note that there are no charges (royalties) for the generated code.
'''
Code Integrator

This is the core of the "glue" generators that Semantix developed for
the European research project ASSERT. It has been enhanced in the
context of Data Modelling and Data Modelling Tuning projects,
and continuous to evolve over the course of other projects.

This code starts by reading the AADL specification of the system.
It then generates the runtime bridge-code that will map the message
data structures from those generated by the Semantix Certified ASN.1
compiler to/from those generated by the modeling tool used to
functionally model the APLC subsystem (e.g. SCADE, ObjectGeode,
Matlab/Simulink, C, Ada, etc).

The code generation is done via user-visible (and editable) backends.

There are three kinds of backends:

1. Synchronous backends
=======================

For these, the working logic is:

for each subprogram implementation
    Load B mapper
    call OnStartup
    for each subprogram param
        Call OnBasic/OnSequence/OnEnumerated etc
    call OnShutdown

That is, there is OnStartup/OnInteger/OnSequence/.../OnShutdown cycle
done PER EACH SUBPROGRAM.

2. Asynchronous backends
========================

Asynchronous backends are only generating standalone encoders and decoders
(they are not doing this per sp.param).

The working logic is therefore different

OnStartup called ONCE for each async backend in use (used by this system's PIs)
Via the asynchronous.py, after visiting all params and collecting them,
for each asn.1 type that is actually used (at least once) as a param:
    Call Encoder and Decoder
Call OnShutdown ONCE for each async backend in use (used by this system's PIs)

3. Special backends
===================

GUI, Python, (VHDL?), etc...

These have custom requirements, so each one is handled by specific AADL2GLUEC
code. As it is now, the pattern follows that of the synchronous backends,
but with an extra call to OnFinal at the end.
'''

import os
import sys
from distutils import spawn
import importlib.util

from typing import cast, Optional, Dict, List, Tuple, Set, Any  # NOQA pylint: disable=unused-import

from .B_mappers import ada_B_mapper
from .B_mappers import c_B_mapper
from .B_mappers import pyside_B_mapper
from .B_mappers import python_B_mapper
from .B_mappers import rtds_B_mapper
from .B_mappers import simulink_B_mapper
from .B_mappers import micropython_async_B_mapper
from .B_mappers import vhdl_B_mapper
from .B_mappers import zestSC1_B_mapper
from .B_mappers import brave_B_mapper           # Specific CoRA B-mapper for BRAVE
from .B_mappers import zynqzc706_B_mapper       # Specific CoRA-ZynQ B-mapper for the ZynQ ZC706
from .B_mappers import brave_large_B_mapper

from .B_mappers.module_protos import Sync_B_Mapper, Async_B_Mapper

from . import commonPy

from .commonPy.utility import panic, inform
from .commonPy import verify
from .commonPy.cleanupNodes import DiscoverBadTypes, SetOfBadTypenames
from .commonPy.asnParser import Filename, Typename, AST_Lookup, AST_TypesOfFile, AST_Leaftypes  # NOQA pylint: disable=unused-import
from .commonPy.asnAST import AsnNode  # NOQA pylint: disable=unused-import
from .commonPy.aadlAST import ApLevelContainer, Param  # NOQA pylint: disable=unused-import

from . import B_mappers  # NOQA pylint: disable=unused-import

# To unpickle the Py2/ANTLR2-generated pickle file...
#    http://stackoverflow.com/questions/2121874/python-pickling-after-changing-a-modules-directory
from . import commonPy2
sys.modules['commonPy2'] = commonPy2


g_async_mappers = {
    'C': c_B_mapper,
    'MicroPython': micropython_async_B_mapper,
    'Ada': ada_B_mapper,
    'RTDS': rtds_B_mapper,
}


g_sync_mappers = {
    'Simulink': simulink_B_mapper,
    'python': python_B_mapper,
    'vhdl': vhdl_B_mapper,
}


def ParseAADLfilesAndResolveSignals() -> None:
    '''Invokes the ANTLR generated AADL parser, and resolves
all references to AADL Data types into the param._signal member
of each SUBPROGRAM param.'''
#   projectCache = os.getenv("PROJECT_CACHE")
#   if projectCache is not None:
#       if not os.path.isdir(projectCache):
#           try:
#               os.mkdir(projectCache)
#           except:
#               panic("The configured cache folder:\n\n\t" + projectCache +
#                     "\n\n...is not there!\n")
    if "aadlv1" in sys.argv[-1]:
        #  asn2aadlPlus now generates directly a Python file containing all
        #  datatypes, so there is no need to parse the aadl file with Python2
        print('[DMT] importing data types from asn2aadlPlus')
        modPath = sys.argv[-1] + '.py'
        spec = importlib.util.spec_from_file_location('asn1', modPath)
        if spec is not None:
            module = importlib.util.module_from_spec(spec)
            if module is not None and spec.loader is not None:   # appease mypy
                sys.modules['asn1'] = module
                spec.loader.exec_module(module)

    # Load mini_cv python-generated modules
    for minicv in sys.argv[1:-1]:
        modPath = minicv.replace('aadl', 'py')  # mini_cv.py file
        print(f'[DMT] importing interfaces from {modPath}')
        spec = importlib.util.spec_from_file_location('minicv', modPath)
        if spec is not None:
            module = importlib.util.module_from_spec(spec)
            if module is not None and spec.loader is not None:  # appease mypy
                spec.loader.exec_module(module)


def SpecialCodes(asnFile: Optional[str]) -> None:
    '''This function handles the code generations needs that reside outside
the scope of individual parameters (e.g. it needs access to all ASN.1
types). This used to cover Dumpable C/Ada Types and OG headers.'''
    outputDir = commonPy.configMT.outputDir
    asn1SccPath = spawn.find_executable('asn1scc')
    # allow externally-defined flags when calling the asn1 compiler (e.g. to set word size based on target)
    extraFlags = os.getenv("ASN1SCC_FLAGS") or ""
    if asnFile is not None:
        if not asn1SccPath:
            panic("ASN1SCC seems not installed on your system (asn1scc not found in PATH).\n")  # pragma: no cover
        os.system('"{}" -typePrefix asn1Scc {} -Ada -equal -o "{}" "{}"'
                  .format(asn1SccPath, extraFlags, outputDir, '" "'.join([asnFile])))


def getSyncBackend(modelingLanguage: str) -> Sync_B_Mapper:
    if modelingLanguage not in g_sync_mappers:
        panic("Synchronous modeling language '%s' not supported" % modelingLanguage)
    if modelingLanguage == 'vhdl':
        if commonPy.configMT.fpga_mapper == "BRAVE":
            return cast(Sync_B_Mapper, brave_B_mapper)  # pragma: no cover
        elif commonPy.configMT.fpga_mapper == "ZESTSC1":
            return cast(Sync_B_Mapper, zestSC1_B_mapper)  # pragma: no cover
        elif commonPy.configMT.fpga_mapper == "ZYNQZC706":
            return cast(Sync_B_Mapper, zynqzc706_B_mapper)  # pragma: no cover
        elif commonPy.configMT.fpga_mapper == "NGLARGE":
            return cast(Sync_B_Mapper, brave_large_B_mapper)  # pragma: no cover
    return cast(Sync_B_Mapper, g_sync_mappers[modelingLanguage])


def isTypeForbidden(backend, typename, forbiddenTypes):
    if backend in ('QGenC', 'C', 'Ada'):
        return False
    else:
        if typename in forbiddenTypes:
            inform(f"ignoring {typename} because {backend} does not support IA5Strings")
        return typename in forbiddenTypes


# sp means subprogram
# maybeFVname: name of the TASTE function that contains the subprogram.
def ProcessSync(
        modelingLanguage: str,
        asnFile: str,
        sp: ApLevelContainer,
        sp_impl: str,
        maybeFVname: str,
        badTypes: SetOfBadTypenames) -> Sync_B_Mapper:
    backend = getSyncBackend(modelingLanguage)

    # Asynchronous backends are only generating standalone encoders and decoders
    # (they are not doing this per sp.param).
    #
    # They must however do this when they have collected ALL the types they are
    # supposed to handle, so this can only be done when the loop over
    # SystemsAndImplementations has completed. We therefore accumulate them in a
    # container, and call their 'OnShutdown' method (which generates the encoders
    # and decoders) at the end (outside the loop). This of course means that we
    # can only call OnStartup once (when the backend is first loaded)

    # In synchronous tools, always call OnStartup and OnShutdown for each SystemsAndImplementation
    backend.OnStartup(modelingLanguage, asnFile, sp, sp_impl, commonPy.configMT.outputDir, maybeFVname)

    for param in sp._params:
        inform("Creating glue for param %s...", param._id)
        assert asnFile == param._signal._asnFilename
        names = commonPy.asnParser.g_names
        leafTypeDict = commonPy.asnParser.g_leafTypeDict

        inform("This param uses definitions from %s", asnFile)
        nodeTypename = param._signal._asnNodename

        # Check if this type must be skipped
        if isTypeForbidden(modelingLanguage, nodeTypename, badTypes):
            inform("This type is skipped: %s", nodeTypename)
            continue

        node = names[nodeTypename]
        inform("ASN.1 node is %s", nodeTypename)

        # First, make sure we know what leaf type this node is
        if node._isArtificial:
            continue  # artificially created (inner) type

        leafType = leafTypeDict[nodeTypename]
        if leafType in ['BOOLEAN', 'INTEGER', 'REAL', 'OCTET STRING', 'BIT STRING', 'AsciiString', 'NULL']:
            processor = backend.OnBasic
        elif leafType == 'SEQUENCE':
            processor = backend.OnSequence
        elif leafType == 'SET':
            processor = backend.OnSet
        elif leafType == 'CHOICE':
            processor = backend.OnChoice
        elif leafType == 'SEQUENCEOF':
            processor = backend.OnSequenceOf
        elif leafType == 'SETOF':
            processor = backend.OnSetOf
        elif leafType == 'ENUMERATED':
            processor = backend.OnEnumerated
        else:  # pragma: no cover
            panic("Unexpected type of element: %s" % leafType)  # pragma: no cover
        processor(nodeTypename, node, sp, sp_impl, param, leafTypeDict, names)

    # For synchronous backend, call OnShutdown once per each sp_impl
    backend.OnShutdown(modelingLanguage, asnFile, sp, sp_impl, maybeFVname)
    return backend


def getAsyncBackend(modelingLanguage: str) -> Async_B_Mapper:
    if modelingLanguage not in g_async_mappers:
        panic("Asynchronous modeling language '%s' not supported" % modelingLanguage)
    return cast(Async_B_Mapper, g_async_mappers[modelingLanguage])


def ProcessAsync(  # pylint: disable=dangerous-default-value
        modelingLanguage: str,
        asnFile: str,
        sp: ApLevelContainer,
        maybeFVname: str,
        badTypes: SetOfBadTypenames,
        loaded_languages_cache: List[str] = []) -> Async_B_Mapper:  # pylint: disable=invalid-sequence-index

    backend = getAsyncBackend(modelingLanguage)

    # Asynchronous backends are only generating standalone encoders and decoders
    # (they are not doing this per sp.param).
    #
    # They must however do this when they have collected ALL the types they are
    # supposed to handle, so this can only be done when the loop over
    # SystemsAndImplementations has completed. We therefore accumulate them in a
    # container, and call their 'OnShutdown' method (which generates the encoders
    # and decoders) at the end (outside the loop). This of course means that we
    # can only call OnStartup once (when the backend is first loaded)
    if modelingLanguage not in loaded_languages_cache:
        loaded_languages_cache.append(modelingLanguage)
        # Only call OnStartup ONCE for asynchronous backends
        # Also notice, no SP or SPIMPL are passed. We are asynchronous, so
        # we only generate "generic" encoders and decoders, not SP-specific ones.
        backend.OnStartup(modelingLanguage, asnFile, commonPy.configMT.outputDir, maybeFVname)

    for param in sp._params:
        inform("Creating glue for param %s...", param._id)
        assert asnFile == param._signal._asnFilename
        names = commonPy.asnParser.g_names
        leafTypeDict = commonPy.asnParser.g_leafTypeDict

        inform("This param uses definitions from %s", asnFile)
        for nodeTypename, node in names.items():
            # Check if this type must be skipped
            if isTypeForbidden(modelingLanguage, nodeTypename, badTypes):
                inform("This type is skipped: %s", nodeTypename)
                continue

            inform("ASN.1 node is %s", nodeTypename)

            # First, make sure we know what leaf type this node is
            if node._isArtificial:
                continue  # artificially created (inner) type

            leafType = leafTypeDict[nodeTypename]
            if leafType in ['BOOLEAN', 'INTEGER', 'REAL', 'OCTET STRING', 'AsciiString', 'BIT STRING', 'NULL']:
                processor = backend.OnBasic
            elif leafType == 'SEQUENCE':
                processor = backend.OnSequence
            elif leafType == 'SET':
                processor = backend.OnSet
            elif leafType == 'CHOICE':
                processor = backend.OnChoice
            elif leafType == 'SEQUENCEOF':
                processor = backend.OnSequenceOf
            elif leafType == 'SETOF':
                processor = backend.OnSetOf
            elif leafType == 'ENUMERATED':
                processor = backend.OnEnumerated
            else:  # pragma: no cover
                panic("Unexpected type of element: %s" % leafType)  # pragma: no cover
            processor(nodeTypename, node, leafTypeDict, names)
    return backend


def ProcessCustomBackends(
        # Taking list of tuples made of (spName, sp_impl, language, maybeFVname)
        asnFile: Optional[str],
        SystemsAndImplementations: List[Tuple[str, str, str, str, str]]) -> None:

    # The code generators for GUIs, Python mappers and VHDL mappers are different: they need access to
    # both ASN.1 types and SP params.
    # Custom code follows...

    # Do we need to handle any special subprograms?
    workedOnGUIs = False
    workedOnVHDL = False

    def getCustomBackends(lang: str) -> List[Sync_B_Mapper]:  # pylint: disable=invalid-sequence-index
        if lang.lower() in ["gui_pi", "gui_ri"]:
            return [cast(Sync_B_Mapper, x) for x in [python_B_mapper, pyside_B_mapper]]  # pragma: no cover
        elif lang.lower() == "vhdl":  # pragma: no cover
            if commonPy.configMT.fpga_mapper == "BRAVE":
                return [cast(Sync_B_Mapper, brave_B_mapper)]  # pragma: no cover
            elif commonPy.configMT.fpga_mapper == "ZESTSC1":
                return [cast(Sync_B_Mapper, zestSC1_B_mapper)]  # pragma: no cover
            elif commonPy.configMT.fpga_mapper == "ZYNQZC706":
                return [cast(Sync_B_Mapper, zynqzc706_B_mapper)]  # pragma: no cover
            elif commonPy.configMT.fpga_mapper == "NGLARGE":
                return [cast(Sync_B_Mapper, brave_large_B_mapper)]  # pragma: no cover
            else:
                return [cast(Sync_B_Mapper, vhdl_B_mapper)]  # pragma: no cover
        else:
            panic("Unexpected call of getCustomBackends...")  # pragma: no cover

    # Add call to the VHDL B-mapper also for C and Simulink functions (x[2]) with FPGA configuration(s) defined (x[4])
    for si in [x for x in SystemsAndImplementations if x[2] is not None and (x[2].lower() in ["gui_ri", "gui_pi", "vhdl"] or ((x[2].lower() == "c" or x[2].lower() == "simulink") and len(x)>4 and x[4] != ''))]:
        # We do, start the work
        spName, sp_impl, lang, maybeFVname = si[0], si[1], si[2], si[3]
        # Add call to the VHDL B-mapper also for C and Simulink functions (si[2]) with FPGA configuration(s) defined (si[4])
        if (si[2].lower() == "c" or si[2].lower() == "simulink") and len(si)>4 and si[4] != '':
            # pretend its VHDL
            lang = "vhdl"
        sp = commonPy.aadlAST.g_apLevelContainers[spName]
        if not sp._params:
            if lang.lower() == "gui_ri":  # pragma: no cover
                if "gui_polling" not in sp._id:  # pragma: no cover
                    panic("Due to wxWidgets limitations, your TCs must have at least one parameter (fix %s)" % sp._id)  # pragma: no cover
            continue  # pragma: no cover
        if lang.lower() in ["gui_pi", "gui_ri"]:
            workedOnGUIs = True
        if lang.lower() == "vhdl":
            workedOnVHDL = True  # pragma: no cover
        inform("Creating %s for %s.%s", lang.upper(), sp._id, sp_impl)

        # Necessary for mypy, but guaranteed by the check above for empty sp._params.
        assert asnFile is not None

        for backend in getCustomBackends(lang):
            backend.OnStartup(lang, asnFile, sp, sp_impl, commonPy.configMT.outputDir, maybeFVname)
        for param in sp._params:
            inform("Processing param %s...", param._id)
            assert asnFile == param._signal._asnFilename
            names = commonPy.asnParser.g_names
            leafTypeDict = commonPy.asnParser.g_leafTypeDict
            nodeTypename = param._signal._asnNodename
            node = names[nodeTypename]
            inform("ASN.1 node is %s", nodeTypename)
            # if node._isArtificial:
            #     continue # artificially created (inner) type pragma: no cover
            leafType = leafTypeDict[nodeTypename]
            if leafType in ['BOOLEAN', 'INTEGER', 'REAL', 'OCTET STRING', 'AsciiString', 'BIT STRING', 'NULL']:
                for backend in getCustomBackends(lang):
                    backend.OnBasic(nodeTypename, node, sp, sp_impl, param, leafTypeDict, names)
            elif leafType in ['SEQUENCE', 'SET', 'CHOICE', 'SEQUENCEOF', 'SETOF', 'ENUMERATED']:
                for backend in getCustomBackends(lang):
                    if leafType == 'SEQUENCE':
                        processor = backend.OnSequence
                    elif leafType == 'SET':
                        processor = backend.OnSet
                    elif leafType == 'CHOICE':
                        processor = backend.OnChoice
                    elif leafType == 'SEQUENCEOF':
                        processor = backend.OnSequenceOf
                    elif leafType == 'SETOF':
                        processor = backend.OnSetOf
                    elif leafType == 'ENUMERATED':
                        processor = backend.OnEnumerated
                    processor(nodeTypename, node, sp, sp_impl, param, leafTypeDict, names)
            else:  # pragma: no cover
                panic("Unexpected type of element: %s" % leafTypeDict[nodeTypename])  # pragma: no cover
        for backend in getCustomBackends(lang):
            backend.OnShutdown(lang, asnFile, sp, sp_impl, maybeFVname)

    # if we processed any GUI subprogram, add footers and close files
    if workedOnGUIs:
        for backend in getCustomBackends('gui_ri'):
            backend.OnFinal()
    # if we processed any VHDL subprogram, add footers and close files
    if workedOnVHDL:
        for backend in getCustomBackends('vhdl'):  # pragma: no cover
            backend.OnFinal()  # pragma: no cover


def main() -> None:
    if "-pdb" in sys.argv:
        sys.argv.remove("-pdb")  # pragma: no cover
        import pdb  # pragma: no cover pylint: disable=wrong-import-position,wrong-import-order
        pdb.set_trace()  # pragma: no cover pylint: disable=forgotten-debug-statement

    use_ASN1SCC_allboards_support = "-allboards" in sys.argv
    if use_ASN1SCC_allboards_support:
        sys.argv.remove("-allboards")  # pragma: no cover
        extraFlags = os.getenv("ASN1SCC_FLAGS") or ""  # pragma: no cover
        extraFlags += " --target allboards "  # pragma: no cover
        os.environ["ASN1SCC_FLAGS"] = extraFlags  # pragma: no cover

    if "-profile" in sys.argv:
        sys.argv.remove("-profile")
        import cProfile
        import pstats
        import io
        pr = cProfile.Profile()
        pr.enable()
        import atexit

        def dumpSpeedData() -> None:
            pr.disable()
            s = io.StringIO()
            sortby = 'cumulative'
            ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
            ps.print_stats()
            print(s.getvalue())
        atexit.register(dumpSpeedData)

    if "-v" in sys.argv:
        import pkg_resources  # pragma: no cover
        version = pkg_resources.require("dmt")[0].version  # pragma: no cover
        print("aadl2glueC v" + str(version))  # pragma: no cover
        sys.exit(1)  # pragma: no cover

    if sys.argv.count("-o") != 0:
        idx = sys.argv.index("-o")
        try:
            commonPy.configMT.outputDir = os.path.normpath(sys.argv[idx + 1]) + os.sep
        except:  # pragma: no cover
            panic('Usage: %s [-v] [-verbose] [-fpga <BRAVE|ZESTSC1|ZYNQZC706|NGLARGE>] [-o dirname] input1.aadl [input2.aadl] ...\n' % sys.argv[0])  # pragma: no cover
        del sys.argv[idx]
        del sys.argv[idx]
        if not os.path.isdir(commonPy.configMT.outputDir):
            panic("'%s' is not a directory!\n" % commonPy.configMT.outputDir)  # pragma: no cover
    if "-onlySP" in sys.argv:  # pragma: no cover
        commonPy.configMT.g_bOnlySubprograms = True  # pragma: no cover
        sys.argv.remove("-onlySP")  # pragma: no cover
    if "-verbose" in sys.argv:
        commonPy.configMT.verbose = True
        sys.argv.remove("-verbose")

    if "-fpga" in sys.argv:  # pragma: no cover
        idx = sys.argv.index("-fpga")
        try:
            commonPy.configMT.fpga_mapper = os.path.normpath(sys.argv[idx + 1])
        except:  # pragma: no cover
            panic('Usage: %s [-v] [-verbose] [-fpga <BRAVE|ZESTSC1|ZYNQZC706|NGLARGE>] [-o dirname] input1.aadl [input2.aadl] ...\n' % sys.argv[0])  # pragma: no cover
        if commonPy.configMT.fpga_mapper == '' or commonPy.configMT.fpga_mapper not in ['BRAVE', 'ZESTSC1', 'ZYNQZC706', 'NGLARGE']:
            panic('Usage: %s [-v] [-verbose] [-fpga <BRAVE|ZESTSC1|ZYNQZC706|NGLARGE>] [-o dirname] input1.aadl [input2.aadl] ...\n' % sys.argv[0])  # pragma: no cover
        del sys.argv[idx]
        del sys.argv[idx]

    # No other options must remain in the cmd line...
    if len(sys.argv) < 2:
        panic('Usage: %s [-v] [-verbose] [-fpga <BRAVE|ZESTSC1|ZYNQZC706|NGLARGE>] [-o dirname] input1.aadl [input2.aadl] ...\n' % sys.argv[0])  # pragma: no cover
    commonPy.configMT.showCode = True
    for f in sys.argv[1:]:
        if not os.path.isfile(f):
            panic("'%s' is not a file!\n" % f)  # pragma: no cover

    ParseAADLfilesAndResolveSignals()

    uniqueDataFiles = {}  # type: Dict[Filename, Dict[str, List[ApLevelContainer]]]
    for sp in list(commonPy.aadlAST.g_apLevelContainers.values()):
        for param in sp._params:
            uniqueDataFiles.setdefault(param._signal._asnFilename, {})
            uniqueDataFiles[param._signal._asnFilename].setdefault(sp._language, [])
            uniqueDataFiles[param._signal._asnFilename][sp._language].append(sp)

    asnFile = None  # type: Optional[str]
    asn1files = list(uniqueDataFiles.keys())
    if len(asn1files) == 1:
        asnFile = asn1files[0]
        inform("Checking that all base nodes have mandatory ranges set in %s..." % asnFile)
        commonPy.asnParser.ParseAsnFileList(asn1files)
    elif asn1files:
        panic("There appear to be more than one ASN.1 files referenced (%s)..." % str(asn1files))

    if asnFile is not None:
        names = commonPy.asnParser.g_names
        for node in names.values():
            verify.VerifyRanges(node, names)

    SystemsAndImplementations = commonPy.aadlAST.g_subProgramImplementations[:]
    SystemsAndImplementations.extend(commonPy.aadlAST.g_threadImplementations[:])
    SystemsAndImplementations.extend(commonPy.aadlAST.g_processImplementations[:])

    # If some AST nodes must be skipped (for any reason), go learn about them
    badTypes = DiscoverBadTypes()

    # Update ASN.1 nodes to carry size info (only for Signal params)
    for si in SystemsAndImplementations:
        spName, sp_impl, modelingLanguage = si[0], si[1], si[2]
        sp = commonPy.aadlAST.g_apLevelContainers[spName]
        for param in sp._params:
            # If there is a parameter used, then there MUST be an asnFile referenced!
            assert asnFile == param._signal._asnFilename
            nodeTypename = param._signal._asnNodename
            node = commonPy.asnParser.g_names[nodeTypename]
            if (nodeTypename in badTypes) and (
                    modelingLanguage not in ('QGenC', 'C', 'Ada', "GUI_PI", "GUI_RI")):
                panic("For type %s:\n\tIA5String and types that depend on them cannot "
                      "be used as a parameter.\n\tUse OCTET STRINGs instead!\n\t(%s)" % (
                          nodeTypename, node.Location()))  # pragma: no cover
                # (typo?) node._asnSize = param._signal._asnSize

    if {"ada", "qgenada"} & {y[2].lower() for y in SystemsAndImplementations}:
        SpecialCodes(asnFile)

    asynchronousBackends = set([])  # type: Set[Async_B_Mapper]

    # Moving to static typing - no more dynamic imports,
    # so this information must be statically available
    async_languages = list(g_async_mappers.keys())

    for si in SystemsAndImplementations:
        spName, sp_impl, modelingLanguage, maybeFVname = si[0], si[1], si[2], si[3]
        if modelingLanguage is None:
            continue  # pragma: no cover
        sp = commonPy.aadlAST.g_apLevelContainers[spName]
        inform("Creating glue for parameters of %s.%s...", sp._id, sp_impl)

        if not sp._params and not sp._simulinkInterfaceType == "step":
            # Avoid generating empty glue - no parameters for this APLC
            continue

        # All SCADE versions are handled by lustre_B_mapper
        # if modelingLanguage[:6] == "Lustre" or modelingLanguage[:5] == "SCADE":
        #    modelingLanguage = "Lustre"  # pragma: no cover

        # The code for these mappers needs C ASN.1 codecs
        if modelingLanguage.lower() in ["gui_ri", "gui_pi", "vhdl", "rhapsody"]:
            modelingLanguage = "C"

        # Necessary for mypy, but guaranteed by the check above for empty sp._params.
        assert asnFile is not None

        if modelingLanguage in async_languages:
            m = ProcessAsync(modelingLanguage, asnFile, sp, maybeFVname, badTypes)
            asynchronousBackends.add(m)
        else:
            ProcessSync(modelingLanguage, asnFile, sp, sp_impl, maybeFVname, badTypes)

    # SystemsAndImplementation loop completed - time to call OnShutdown ONCE for each async backend that we loaded
    for asyncBackend in asynchronousBackends:
        # Appeasing mypy: asnFile can be None here, so I checked all
        # B mappers - no-one depends on a None value for the asnFile.
        asyncBackend.OnShutdown(modelingLanguage, '' if not asnFile else asnFile, maybeFVname)

    ProcessCustomBackends(asnFile, SystemsAndImplementations)


if __name__ == "__main__":
    main()
