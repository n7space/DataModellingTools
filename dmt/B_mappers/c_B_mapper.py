#
# (C) Semantix Information Technologies, Neuropublic, and European Space Agency
#
# Licensed under the GPL with Runtime Exception.
# Note that there are no charges (royalties) for the generated code.
'''
This is the implementation of the code mapper for C code.
As initially envisioned, ASSERT technology is not supposed
to support manually-made systems. A migration path, however,
that allows legacy hand-written code and modelling-tool
generated code to co-exist, can be beneficial in allowing
for a smooth transition. To that end, this backend (as well as
the Ada one) are written.

This is a backend for Semantix's code generator B (aadl2glueC).

C is a member of the asynchronous "club" (SDL, etc);
The subsystem developer (or rather, the APLC developer) is using
native C/C++ code to work with code generated by modelling tools.
To that end, this backend creates "glue" functions for input and
output parameters, which have C callable interfaces.
'''

from typing import List

from ..commonPy.utility import panic
from ..commonPy.asnAST import (
    AsnAsciiString, AsnNode)
from ..commonPy.asnParser import AST_Lookup, AST_Leaftypes
# from ..commonPy.recursiveMapper import RecursiveMapper
from .asynchronousTool import ASynchronousToolGlueGenerator

isAsynchronous = True


class C_GlueGenerator(ASynchronousToolGlueGenerator):
    def __init__(self) -> None:
        ASynchronousToolGlueGenerator.__init__(self)

    def Version(self) -> None:
        print("Code generator: " + "$Id: c_B_mapper.py 2390 2012-07-19 12:39:17Z ttsiodras $")  # pragma: no cover

    def HeadersOnStartup(self, unused_asnFile: str, unused_outputDir: str, unused_maybeFVname: str) -> None:
        self.C_HeaderFile.write("#include \"%s.h\" // Space certified compiler generated\n\n" %
                                self.asn_name)
        self.C_HeaderFile.write("#include \"../../system_config.h\" // Choose ASN.1 Types to use\n\n")

    def Encoder(self, nodeTypename: str, node: AsnNode, leafTypeDict: AST_Leaftypes, names: AST_Lookup, encoding: str) -> None:
        if encoding.lower() not in self.supportedEncodings:
            panic(str(self.__class__) + ": in (%s), encoding can be one of %s (not '%s')" %  # pragma: no cover
                  (nodeTypename, self.supportedEncodings, encoding))  # pragma: no cover
        tmpSpName = "Encode_%s_%s" % \
            ({"uper": "UPER", "native": "NATIVE", "acn": "ACN"}[encoding.lower()],
             self.CleanNameAsToolWants(nodeTypename))

        needDefine = "#ifdef __NEED_%s_%s\n" % (
            self.CleanNameAsToolWants(nodeTypename),
            encoding.upper())
        self.C_HeaderFile.write(needDefine)
        if encoding.lower() in ["uper", "acn"]:
            self.C_HeaderFile.write(
                "int %s(void *pBuffer, size_t iMaxBufferSize, %sasn1Scc%s *pSrc, int *errorCode);\n" %
                (tmpSpName, "" if encoding.lower() == "acn" else "const ",
                 self.CleanNameAsToolWants(nodeTypename)))
        elif encoding.lower() == "native":
            self.C_HeaderFile.write(
                "int %s(void *pBuffer, size_t iMaxBufferSize, %sasn1Scc%s *pSrc);\n" %
                (tmpSpName, "" if encoding.lower() == "acn" else "const ",
                 self.CleanNameAsToolWants(nodeTypename)))
        self.C_HeaderFile.write("#endif\n\n")
        self.C_SourceFile.write(needDefine)
        if encoding.lower() in ["uper", "acn"]:
            self.C_SourceFile.write(
                "int %s(void *pBuffer, size_t iMaxBufferSize, %sasn1Scc%s *pSrc, int *errorCode)\n{\n    (void)iMaxBufferSize;\n" %
                (tmpSpName, "" if encoding.lower() == "acn" else "const ",
                 self.CleanNameAsToolWants(nodeTypename)))
        elif encoding.lower() == "native":
            self.C_SourceFile.write(
                "int %s(void *pBuffer, size_t iMaxBufferSize, %sasn1Scc%s *pSrc)\n{\n    (void)iMaxBufferSize;\n" %
                (tmpSpName, "" if encoding.lower() == "acn" else "const ",
                 self.CleanNameAsToolWants(nodeTypename)))

        if encoding.lower() in ["uper", "acn"]:
            self.C_SourceFile.write("    int outErrorCode;\n")
            self.C_SourceFile.write("    STATIC BitStream strm;\n\n")
            self.C_SourceFile.write("    BitStream_Init(&strm, pBuffer, iMaxBufferSize);\n")

        if encoding.lower() in ["uper", "acn"]:
            self.C_SourceFile.write("    if (asn1Scc%s_%sEncode(pSrc, &strm, &outErrorCode, TRUE) == FALSE) {\n" %
                                    (self.CleanNameAsToolWants(nodeTypename),
                                     ("ACN_" if encoding.lower() == "acn" else "")))
            self.C_SourceFile.write("       if (errorCode != NULL) {\n")
            self.C_SourceFile.write("           *errorCode = outErrorCode;\n")
            self.C_SourceFile.write("       }\n")
            self.C_SourceFile.write("#ifdef __unix__\n")
            self.C_SourceFile.write(
                '\tfprintf(stderr, "Could not encode %s (at %%s, %%d), errorCode was %%d\\n", __FILE__, __LINE__, outErrorCode);\n' % nodeTypename)
            self.C_SourceFile.write("#endif\n")
            self.C_SourceFile.write("        return -1;\n")
            self.C_SourceFile.write("    } else {\n")
            self.C_SourceFile.write("        return BitStream_GetLength(&strm);\n")
            self.C_SourceFile.write("    }\n")
            self.C_SourceFile.write("}\n")
            self.C_SourceFile.write("#endif\n\n")
        elif encoding.lower() == "native":
            self.C_SourceFile.write("    memcpy(pBuffer, pSrc, sizeof(asn1Scc%s) );\n" %
                                    (self.CleanNameAsToolWants(nodeTypename)))
            self.C_SourceFile.write("    return sizeof(asn1Scc%s);\n" %
                                    self.CleanNameAsToolWants(nodeTypename))
            self.C_SourceFile.write("}\n")
            self.C_SourceFile.write("#endif\n\n")

    def Decoder(self, nodeTypename: str, node: AsnNode, leafTypeDict: AST_Leaftypes, names: AST_Lookup, encoding: str) -> None:
        if encoding.lower() not in self.supportedEncodings:
            panic(str(self.__class__) + ": in (%s), encoding can be one of %s (not '%s')" %  # pragma: no cover
                  (nodeTypename, self.supportedEncodings, encoding))  # pragma: no cover

        tmpSpName = "Decode_%s_%s" % \
            ({"uper": "UPER", "native": "NATIVE", "acn": "ACN"}[encoding.lower()],
             self.CleanNameAsToolWants(nodeTypename))

        needDefine = "#ifdef __NEED_%s_%s\n" % (
            self.CleanNameAsToolWants(nodeTypename),
            encoding.upper())
        self.C_HeaderFile.write(needDefine)
        if encoding.lower() in ["uper", "acn"]:
            self.C_HeaderFile.write(
                "int %s(asn1Scc%s *pDst, void *pBuffer, size_t iBufferSize, int *errorCode);\n" %
                (tmpSpName, self.CleanNameAsToolWants(nodeTypename)))
        elif encoding.lower() == "native":
            self.C_HeaderFile.write(
                "int %s(asn1Scc%s *pDst, void *pBuffer, size_t iBufferSize);\n" %
                (tmpSpName, self.CleanNameAsToolWants(nodeTypename)))
        self.C_HeaderFile.write("#endif\n\n")
        self.C_SourceFile.write(needDefine)
        if encoding.lower() in ["uper", "acn"]:
            self.C_SourceFile.write(
                "int %s(asn1Scc%s *pDst, void *pBuffer, size_t iBufferSize, int *errorCode)\n{\n    (void)iBufferSize;\n" %
                (tmpSpName, self.CleanNameAsToolWants(nodeTypename)))
        elif encoding.lower() == "native":
            self.C_SourceFile.write(
                "int %s(asn1Scc%s *pDst, void *pBuffer, size_t iBufferSize)\n{\n    (void)iBufferSize;\n" %
                (tmpSpName, self.CleanNameAsToolWants(nodeTypename)))

        if encoding.lower() in ["uper", "acn"]:
            self.C_SourceFile.write("    int outErrorCode;\n\n")
            self.C_SourceFile.write("    STATIC BitStream strm;\n\n")
            self.C_SourceFile.write("    BitStream_AttachBuffer(&strm, pBuffer, iBufferSize);\n\n")
            self.C_SourceFile.write("    if (asn1Scc%s_%sDecode(pDst, &strm, &outErrorCode)) {\n" %
                                    (self.CleanNameAsToolWants(nodeTypename),
                                     "ACN_" if encoding.lower() == "acn" else ""))
            self.C_SourceFile.write("        /* Decoding succeeded */\n")
        elif encoding.lower() == "native":
            if isinstance(node, AsnAsciiString):
                self.C_SourceFile.write("    memcpy(pDst, pBuffer, sizeof(asn1Scc%s));\n    {\n" %
                                        (self.CleanNameAsToolWants(nodeTypename)))
            else:
                self.C_SourceFile.write("    *pDst = *(asn1Scc%s *) pBuffer;\n    {\n" %
                                        (self.CleanNameAsToolWants(nodeTypename)))

        if encoding.lower() in ["uper", "acn"]:
            self.C_SourceFile.write("        return 0;\n")
            self.C_SourceFile.write("    } else {\n")
            self.C_SourceFile.write("       if (errorCode != NULL) {\n")
            self.C_SourceFile.write("           *errorCode = outErrorCode;\n")
            self.C_SourceFile.write("       }\n")
            self.C_SourceFile.write("#ifdef __unix__\n")
            self.C_SourceFile.write(
                '\tfprintf(stderr, "Could not decode %s (at %%s, %%d), error code was %%d\\n", __FILE__, __LINE__, outErrorCode);\n' % nodeTypename)
            self.C_SourceFile.write("#endif\n")
            self.C_SourceFile.write("        return -1;\n")
            self.C_SourceFile.write("    }\n")
            self.C_SourceFile.write("}\n")
            self.C_SourceFile.write("#endif\n\n")
        else:
            self.C_SourceFile.write("        return 0;\n")
            self.C_SourceFile.write("    }\n")
            self.C_SourceFile.write("}\n")
            self.C_SourceFile.write("#endif\n\n")


cBackend: C_GlueGenerator


def OnStartup(modelingLanguage: str, asnFile: str, outputDir: str, maybeFVname: str) -> None:
    global cBackend
    cBackend = C_GlueGenerator()
    cBackend.OnStartup(modelingLanguage, asnFile, outputDir, maybeFVname)


def OnBasic(nodeTypename: str, node: AsnNode, leafTypeDict: AST_Leaftypes, names: AST_Lookup) -> None:
    cBackend.OnBasic(nodeTypename, node, leafTypeDict, names)


def OnSequence(nodeTypename: str, node: AsnNode, leafTypeDict: AST_Leaftypes, names: AST_Lookup) -> None:
    cBackend.OnSequence(nodeTypename, node, leafTypeDict, names)


def OnSet(nodeTypename: str, node: AsnNode, leafTypeDict: AST_Leaftypes, names: AST_Lookup) -> None:
    cBackend.OnSet(nodeTypename, node, leafTypeDict, names)  # pragma: nocover


def OnEnumerated(nodeTypename: str, node: AsnNode, leafTypeDict: AST_Leaftypes, names: AST_Lookup) -> None:
    cBackend.OnEnumerated(nodeTypename, node, leafTypeDict, names)


def OnSequenceOf(nodeTypename: str, node: AsnNode, leafTypeDict: AST_Leaftypes, names: AST_Lookup) -> None:
    cBackend.OnSequenceOf(nodeTypename, node, leafTypeDict, names)


def OnSetOf(nodeTypename: str, node: AsnNode, leafTypeDict: AST_Leaftypes, names: AST_Lookup) -> None:
    cBackend.OnSetOf(nodeTypename, node, leafTypeDict, names)  # pragma: nocover


def OnChoice(nodeTypename: str, node: AsnNode, leafTypeDict: AST_Leaftypes, names: AST_Lookup) -> None:
    cBackend.OnChoice(nodeTypename, node, leafTypeDict, names)


def OnShutdown(modelingLanguage: str, asnFile: str, maybeFVname: str) -> None:
    cBackend.OnShutdown(modelingLanguage, asnFile, maybeFVname)
