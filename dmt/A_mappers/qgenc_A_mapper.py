
# (C) Semantix Information Technologies, Neuropublic, IB Krates
#     and European Space Agency
#
# Licensed under the GPL with Runtime Exception.
# Note that there are no charges (royalties) for the generated code.

import re

from typing import Union, Set, List, IO, Any  # NOQA pylint: disable=unused-import

from ..commonPy.utility import panic, inform
from ..commonPy import asnParser
from ..commonPy.asnAST import (
    AsnBool, AsnInt, AsnReal, AsnEnumerated, AsnSequence, AsnChoice, AsnMetaMember, AsnSequenceOf,
    AsnBasicNode, AsnSequenceOrSetOf, AsnSequenceOrSet, AsnAsciiString, AsnOctetString)
from ..commonPy.asnAST import AsnNode  # NOQA pylint: disable=unused-import
from ..commonPy.createInternalTypes import ScanChildren
from ..commonPy.cleanupNodes import SetOfBadTypenames
from ..commonPy.asnParser import AST_Leaftypes, AST_Lookup

# The files written to
g_dataviewAsnMatLabFile: IO[Any]
g_definitionOfTypesCHeaderFile: IO[Any]

# A map of the ASN.1 types defined so far
g_definedTypes = set()  # type: Set[asnParser.Typename]

g_bHasStartupRunOnce = False


def Version() -> None:
    print("Code generator: " + "$Id: qgenc_A_mapper.py $")  # pragma: no cover


def AppendCHeaderDescription(definitionOfTypesCHeaderFile: IO[Any]) -> None:
    definitionOfTypesCHeaderFile.write("/*\n")
    definitionOfTypesCHeaderFile.write('* Why "#define MyInteger asn1SccMyInteger" ?\n')
    definitionOfTypesCHeaderFile.write("*\n")
    definitionOfTypesCHeaderFile.write("*     For example .asn :\n")
    definitionOfTypesCHeaderFile.write("*         MyInteger ::= INTEGER (0..255)\n")
    definitionOfTypesCHeaderFile.write("*     \n")
    definitionOfTypesCHeaderFile.write("*     Simulink's model uses the data types defined in .asn files and processed by DMT (MyInteger, uint8 - because range is 0 .. 255).\n")
    definitionOfTypesCHeaderFile.write("*     MatLab's s-functions use .c and .h files generated by Kazoo that use the data types generated by the asn1scc compiler.\n")
    definitionOfTypesCHeaderFile.write('*     asn1scc compiler translates the data types defined in .asn files, but adding the "asn1Scc" prefix (asn1SccMyInteger) to names of data types\n')
    definitionOfTypesCHeaderFile.write("*         and uses base types of different size (e.g., uint64_t for non-negative integer on a Linux platform).\n")
    definitionOfTypesCHeaderFile.write("*     One the one hand Simulink's model uses the data types generated by DMT (MyInteger, uint8), but on the other hand s-function uses the data types\n")
    definitionOfTypesCHeaderFile.write("*         generated by asn1scc compiler (asn1SccMyinteger, uint64_t).\n")
    definitionOfTypesCHeaderFile.write("*     This causes a mismatch between the names of the data types and their size.\n")
    definitionOfTypesCHeaderFile.write("*     To avoid this situation it is necessary to use only one data type - asn1SccMyInteger (uint64 > uint8).\n")
    definitionOfTypesCHeaderFile.write("*     For consistency (the entire TASTE environment already uses MyInteger) this file is generated.\n")
    definitionOfTypesCHeaderFile.write("*     During the compilation QGen and TASTE will use asn1SccMyInteger data type, but user in MatLab still can work on MyInteger data type (uint8).\n")
    definitionOfTypesCHeaderFile.write("*     \n")
    definitionOfTypesCHeaderFile.write("*\n")
    definitionOfTypesCHeaderFile.write("* Why some data types have different declaration than \"#define MyDataType asn1SccMyDataType\" ?\n")
    definitionOfTypesCHeaderFile.write("*\n")
    definitionOfTypesCHeaderFile.write("*     In general, there are two ASN1 data types that have different, custom declaration : Choice and IA5String.\n")
    definitionOfTypesCHeaderFile.write("*     In both cases the reason is the same : it is impossible to create \"union\" (Choice) and \"char array[N]\" (IA5String) data type directly in MatLab R2018b.\n")
    definitionOfTypesCHeaderFile.write("*     To avoid this inconvenience, Choice and IA5String have different declaration for MatLab (only for QGenC function block) :\n")
    definitionOfTypesCHeaderFile.write("*       Choice :\n")
    definitionOfTypesCHeaderFile.write("*           generated by asn1scc compiler :\n")
    definitionOfTypesCHeaderFile.write("*               typedef enum {\n")
    definitionOfTypesCHeaderFile.write("*                   ChoiceAliases_NONE,\n")
    definitionOfTypesCHeaderFile.write("*                   ChoiceAliases_integerAliasMember_PRESENT,\n")
    definitionOfTypesCHeaderFile.write("*                   ChoiceAliases_realAliasMember_PRESENT,\n")
    definitionOfTypesCHeaderFile.write("*               } asn1SccChoice_selection;\n")
    definitionOfTypesCHeaderFile.write("*\n")
    definitionOfTypesCHeaderFile.write("*               typedef union {\n")
    definitionOfTypesCHeaderFile.write("*                   asn1SccIntegerAlias integerAliasMember;\n")
    definitionOfTypesCHeaderFile.write("*                   asn1SccRealAlias    realAliasMember;\n")
    definitionOfTypesCHeaderFile.write("*               } asn1SccChoice_unchecked_union; \n")
    definitionOfTypesCHeaderFile.write("*\n")
    definitionOfTypesCHeaderFile.write("*               typedef struct {\n")
    definitionOfTypesCHeaderFile.write("*                   asn1SccChoice_selection       kind;\n")
    definitionOfTypesCHeaderFile.write("*                   asn1SccChoice_unchecked_union u;\n")
    definitionOfTypesCHeaderFile.write("*               } asn1SccChoice;\n")
    definitionOfTypesCHeaderFile.write("*\n")
    definitionOfTypesCHeaderFile.write("*           generated for MatLab (implemented as a bus data type) :\n")
    definitionOfTypesCHeaderFile.write("*               typedef struct {\n")
    definitionOfTypesCHeaderFile.write("*                   int choiceIdx;\n")
    definitionOfTypesCHeaderFile.write("*\n")
    definitionOfTypesCHeaderFile.write("*                   asn1SccUint integerAliasMember;\n")
    definitionOfTypesCHeaderFile.write("*                   asn1Real    realAliasMember;\n")
    definitionOfTypesCHeaderFile.write("*               } Choice;\n")
    definitionOfTypesCHeaderFile.write("*\n")
    definitionOfTypesCHeaderFile.write("*       IA5String :\n")
    definitionOfTypesCHeaderFile.write("*           generated by asn1scc compiler :\n")
    definitionOfTypesCHeaderFile.write("*               typedef char asn1SccIA5String[4];\n")
    definitionOfTypesCHeaderFile.write("* \n")
    definitionOfTypesCHeaderFile.write("*           generated for MatLab (implemented as a bus data type) :\n")
    definitionOfTypesCHeaderFile.write("*               typedef struct {\n")
    definitionOfTypesCHeaderFile.write("*                   asn1SccIA5String arr;\n")
    definitionOfTypesCHeaderFile.write("*               } IA5StringFixedSizeAlias;\n")
    definitionOfTypesCHeaderFile.write("*\n")
    definitionOfTypesCHeaderFile.write("*   As a consequence all data types that use Choice or IA5String inside on any nesting level (Sequence, SequenceOf, etc) have to be redefined.\n")
    definitionOfTypesCHeaderFile.write("*   It is really important in order to use RI (sfunctions) that redefined data types have to be matched with asn1scc would generate.\n")
    definitionOfTypesCHeaderFile.write("*\n")
    definitionOfTypesCHeaderFile.write("*   It is safe to use a IA5String data type in PI/RI (redefined IA5String and IA5String generated by asn1scc compiler are still the same).\n")
    definitionOfTypesCHeaderFile.write("*   It is safe to use a Choice data type in PI (declaration differences will be resolved by wrappers), but usage in RI (sfunctions) is forbidden (asn1SccChoice != Choice).\n")
    definitionOfTypesCHeaderFile.write("*/\n\n")


def OnStartup(unused_modelingLanguage: str, unused_asnFiles: List[str], outputDir: str, unused_badTypes: SetOfBadTypenames) -> None:  # pylint: disable=invalid-sequence-index
    global g_bHasStartupRunOnce
    global g_dataviewAsnMatLabFile
    global g_definitionOfTypesCHeaderFile

    if g_bHasStartupRunOnce:
        return  # pragma: no cover
    else:
        g_bHasStartupRunOnce = True

    g_definedTypes.clear()

    dataviewAsnMatLabFileName = "Simulink_DataView_asn.m"
    definitionOfTypesCHeaderFileName = "simulink_definition_of_types.h"

    inform("QGenC_A_mapper: Creating file '%s' ...", dataviewAsnMatLabFileName)
    g_dataviewAsnMatLabFile = open(outputDir + dataviewAsnMatLabFileName, "w")

    inform("QGenC_A_mapper: Creating file '%s' ...", definitionOfTypesCHeaderFileName)
    g_definitionOfTypesCHeaderFile = open(outputDir + definitionOfTypesCHeaderFileName, "w")

    g_definitionOfTypesCHeaderFile.write("#ifndef SIMULINK_DEFINITION_OF_TYPES_H\n")
    g_definitionOfTypesCHeaderFile.write("#define SIMULINK_DEFINITION_OF_TYPES_H\n")
    g_definitionOfTypesCHeaderFile.write('#include "dataview-uniq.h"\n\n')
    AppendCHeaderDescription(g_definitionOfTypesCHeaderFile)

    CreateDeclarationsForAllTypes(asnParser.g_names, asnParser.g_leafTypeDict)

    g_definitionOfTypesCHeaderFile.write('#endif //SIMULINK_DEFINITION_OF_TYPES_H\n')


def OnBasic(unused_nodeTypename: str, unused_node: AsnBasicNode, unused_leafTypeDict: AST_Leaftypes) -> None:
    pass  # pragma: no cover


def OnSequence(unused_nodeTypename: str, unused_node: AsnSequenceOrSet, unused_leafTypeDict: AST_Leaftypes) -> None:
    pass  # pragma: no cover


def OnSet(unused_nodeTypename: str, unused_node: AsnSequenceOrSet, unused_leafTypeDict: AST_Leaftypes) -> None:
    pass  # pragma: nocover


def OnEnumerated(unused_nodeTypename: str, unused_node: AsnEnumerated, unused_leafTypeDict: AST_Leaftypes) -> None:
    pass  # pragma: no cover


def OnSequenceOf(unused_nodeTypename: str, unused_node: AsnSequenceOrSetOf, unused_leafTypeDict: AST_Leaftypes) -> None:
    pass  # pragma: no cover


def OnSetOf(unused_nodeTypename: str, unused_node: AsnSequenceOrSetOf, unused_leafTypeDict: AST_Leaftypes) -> None:
    pass  # pragma: nocover


def OnChoice(unused_nodeTypename: str, unused_node: AsnChoice, unused_leafTypeDict: AST_Leaftypes) -> None:
    pass  # pragma: no cover


def OnShutdown(unused_badTypes: SetOfBadTypenames) -> None:
    pass


def CleanNameAsSimulinkWants(name: str) -> str:
    return re.sub(r'[^a-zA-Z0-9_]', '_', name)


def MapIntegerForMatLab(node: AsnInt) -> str:
    rangeLower = node._range[0]
    rangeUpper = node._range[1]

    if rangeLower >= 0 and rangeUpper <= 255:
        return "uint8"
    elif rangeLower >= -128 and rangeUpper <= 127:
        return "int8"
    elif rangeLower >= 0 and rangeUpper <= 65535:
        return "uint16"
    elif rangeLower >= -32768 and rangeUpper <= 32767:
        return "int16"
    elif rangeLower >= 0:
        return "uint32"
    else:
        return "int32"


def MapIntegerForC(node: AsnInt) -> str:
    rangeLower = node._range[0]

    if rangeLower < 0:
        return "asn1SccSint"
    else:
        return "asn1SccUint"


def CreateMatLabAliasType(name: str, dataType: str, description: str) -> None:
    g_dataviewAsnMatLabFile.write("% ############################################################\n")
    g_dataviewAsnMatLabFile.write("%% %s\n\n" % (name))

    g_dataviewAsnMatLabFile.write("%s = Simulink.AliasType;\n" % (name))
    g_dataviewAsnMatLabFile.write("%s.BaseType = '%s';\n" % (name, dataType))
    g_dataviewAsnMatLabFile.write("%s.Description = '%s';\n" % (name, description))
    g_dataviewAsnMatLabFile.write("%s.HeaderFile = 'simulink_definition_of_types.h';\n\n" % (name))


def CreateMatLabBusTypeWithArrAndNCountElems(node, name: str, dataType: str, generateNCountMember: bool) -> None:
    needLength = False

    if len(node._range) > 1 and node._range[0] != node._range[1] and generateNCountMember:
        needLength = True

    g_dataviewAsnMatLabFile.write("% ############################################################\n")
    g_dataviewAsnMatLabFile.write("%% %s\n\n" % (name))

    g_dataviewAsnMatLabFile.write("%s_member_arr=Simulink.BusElement;\n" % (name))
    g_dataviewAsnMatLabFile.write("%s_member_arr.Name='arr';\n" % (name))
    g_dataviewAsnMatLabFile.write("%s_member_arr.DataType='%s';\n" % (name, dataType))
    g_dataviewAsnMatLabFile.write("%s_member_arr.Dimensions=%d;\n\n" % (name, node._range[-1]))

    if needLength:
        g_dataviewAsnMatLabFile.write('%s_member_ncount=Simulink.BusElement;\n' % (name))
        g_dataviewAsnMatLabFile.write("%s_member_ncount.Name='nCount';\n" % (name))
        g_dataviewAsnMatLabFile.write("%s_member_ncount.DataType='int32';\n" % (name))
        g_dataviewAsnMatLabFile.write("%s_member_ncount.Dimensions=1;\n\n" % (name))

    g_dataviewAsnMatLabFile.write("%s=Simulink.Bus;\n" % (name))
    g_dataviewAsnMatLabFile.write("%s.HeaderFile = 'simulink_definition_of_types.h';\n" % (name))
    g_dataviewAsnMatLabFile.write("%s.Elements = [%s_member_arr" % (name, name))

    if needLength:
        g_dataviewAsnMatLabFile.write(" %s_member_ncount" % (name))

    g_dataviewAsnMatLabFile.write("];\n\n")


def CreateCDirectDefine(nodeTypenameForSimulink: str) -> None:
    g_definitionOfTypesCHeaderFile.write('#define %s asn1Scc%s\n\n' % (nodeTypenameForSimulink, nodeTypenameForSimulink))


def CreateCStructTypeIA5StringDefine(nodeTypenameForSimulink: str) -> None:
    g_definitionOfTypesCHeaderFile.write('typedef struct {\n')
    g_definitionOfTypesCHeaderFile.write('    asn1Scc%s arr;\n' % nodeTypenameForSimulink)
    g_definitionOfTypesCHeaderFile.write('} %s;\n\n' % nodeTypenameForSimulink)


def CreateCStructTypeSequenceOfDefine(node: AsnSequenceOf, contained: str, nodeTypenameForSimulink: str) -> None:
    g_definitionOfTypesCHeaderFile.write('typedef struct {\n')

    if len(node._range) > 1 and node._range[0] != node._range[1]:
        g_definitionOfTypesCHeaderFile.write('    int nCount;\n\n')

    g_definitionOfTypesCHeaderFile.write('    %s arr[%d];\n' % (contained, node._range[-1]))
    g_definitionOfTypesCHeaderFile.write('} %s;\n\n' % nodeTypenameForSimulink)


def GetSequenceOfBasicType(node: AsnSequenceOf, astLookupDict: AST_Lookup) -> AsnNode:
    containedNode: AsnNode = astLookupDict[node._containedType]

    while isinstance(containedNode, AsnSequenceOf):
        assert containedNode._containedType is not None
        containedNode = astLookupDict[containedNode._containedType]

    return containedNode


def IsSequenceUsingAsciiStringOrChoice(node: AsnSequence, astLookupDict: AST_Lookup) -> bool:
    for member in node._members:
        memberNode = member[1]

        while isinstance(memberNode, AsnMetaMember):
            memberNode = astLookupDict[memberNode._containedType]

        if isinstance(memberNode, (AsnAsciiString, AsnChoice)):
            return True

        elif isinstance(memberNode, AsnSequenceOf):
            basicTypeNode = GetSequenceOfBasicType(memberNode, astLookupDict)

            if isinstance(basicTypeNode, (AsnAsciiString, AsnChoice)):
                return True

        elif isinstance(memberNode, AsnSequence):
            return IsSequenceUsingAsciiStringOrChoice(memberNode, astLookupDict)

    return False


def ProcessBool(node: AsnBool, nodeTypename: str, nodeTypenameForSimulink: str, astLookupDict: AST_Lookup) -> None:
    # pylint: disable=unused-argument

    CreateMatLabAliasType(nodeTypenameForSimulink, "boolean", 'A simple BOOLEAN')
    CreateCDirectDefine(nodeTypenameForSimulink)


def ProcessInt(node: AsnInt, nodeTypename: str, nodeTypenameForSimulink: str, astLookupDict: AST_Lookup) -> None:
    # pylint: disable=unused-argument

    CreateMatLabAliasType(nodeTypenameForSimulink, MapIntegerForMatLab(node), "range is %s" % str(node._range))
    CreateCDirectDefine(nodeTypenameForSimulink)


def ProcessReal(node: AsnReal, nodeTypename: str, nodeTypenameForSimulink: str, astLookupDict: AST_Lookup) -> None:
    # pylint: disable=unused-argument

    CreateMatLabAliasType(nodeTypenameForSimulink, "double", "range is %s" % str(node._range))
    CreateCDirectDefine(nodeTypenameForSimulink)


def ProcessIA5String(node: AsnAsciiString, nodeTypename: str, nodeTypenameForSimulink: str, astLookupDict: AST_Lookup) -> None:
    # pylint: disable=unused-argument

    if not node._range:
        panic("QGenC_A_mapper: ia5string (in %s) must have a SIZE constraint!\n" % node.Location())  # pragma: no cover

    CreateMatLabBusTypeWithArrAndNCountElems(node, nodeTypenameForSimulink, "uint8", False)
    CreateCStructTypeIA5StringDefine(nodeTypenameForSimulink)


def ProcessOctetString(node: AsnOctetString, nodeTypename: str, nodeTypenameForSimulink: str, astLookupDict: AST_Lookup) -> None:
    # pylint: disable=unused-argument

    if not node._range:
        panic("QGenC_A_mapper: octet string (in %s) must have a SIZE constraint!\n" % node.Location())  # pragma: no cover

    CreateMatLabBusTypeWithArrAndNCountElems(node, nodeTypenameForSimulink, "uint8", True)
    CreateCDirectDefine(nodeTypenameForSimulink)


def ProcessEnum(node: AsnEnumerated, nodeTypename: str, nodeTypenameForSimulink: str, astLookupDict: AST_Lookup) -> None:
    # pylint: disable=unused-argument

    g_dataviewAsnMatLabFile.write("% ############################################################\n")
    g_dataviewAsnMatLabFile.write("%% %s\n\n" % nodeTypename)

    g_dataviewAsnMatLabFile.write("%s_names = {" % nodeTypenameForSimulink)
    for member in node._members:
        enumerantName = member[0]
        g_dataviewAsnMatLabFile.write(" '%s_%s'" % (nodeTypenameForSimulink, enumerantName))
    g_dataviewAsnMatLabFile.write("};\n")

    g_dataviewAsnMatLabFile.write("%s_values = [" % nodeTypenameForSimulink)
    for member in node._members:
        enumerantValue = member[1]

        if enumerantValue is None:
            panic("QGenC_A_mapper: must have values for enumerants (%s)" % node.Location())  # pragma: no cover

        g_dataviewAsnMatLabFile.write(" %s" % enumerantValue)
    g_dataviewAsnMatLabFile.write("];\n\n")

    g_dataviewAsnMatLabFile.write("% enumeration will be defined in memory\n")
    g_dataviewAsnMatLabFile.write("Simulink.defineIntEnumType('%s', ...\n" % nodeTypenameForSimulink)
    g_dataviewAsnMatLabFile.write("                            %s_names, ...\n" % nodeTypenameForSimulink)
    g_dataviewAsnMatLabFile.write("                            %s_values, ...\n" % nodeTypenameForSimulink)
    g_dataviewAsnMatLabFile.write("                           'Description', '%s enumeration', ...\n" % nodeTypenameForSimulink)
    g_dataviewAsnMatLabFile.write("                           'DefaultValue', %s_names{1}, ...\n" % nodeTypenameForSimulink)
    g_dataviewAsnMatLabFile.write("                           'HeaderFile', 'simulink_definition_of_types.h', ...\n")
    g_dataviewAsnMatLabFile.write("                           'DataScope', 'Imported', ...\n")
    g_dataviewAsnMatLabFile.write("                           'AddClassNameToEnumNames', false, ...\n")
    g_dataviewAsnMatLabFile.write("                           'StorageType', 'int32');\n\n")

    CreateCDirectDefine(nodeTypenameForSimulink)


def ProcessSequenceChoice(node: Union[AsnSequence, AsnChoice], nodeTypename: str, nodeTypenameForSimulink: str, astLookupDict: AST_Lookup) -> None:
    if not node._members:
        return

    isSequenceUsingAsciiStringOrChoice = False

    if isinstance(node, AsnSequence):
        isSequenceUsingAsciiStringOrChoice = IsSequenceUsingAsciiStringOrChoice(node, astLookupDict)

    isChoice = isinstance(node, AsnChoice)

    if isSequenceUsingAsciiStringOrChoice or isChoice:
        g_definitionOfTypesCHeaderFile.write('typedef struct {\n')
    else:
        CreateCDirectDefine(nodeTypenameForSimulink)

    memberNumber = 0

    g_dataviewAsnMatLabFile.write("% ############################################################\n")
    g_dataviewAsnMatLabFile.write("%% %s\n\n" % nodeTypename)

    if isChoice:
        memberNumber += 1

        busMemberName = "%s_member%02d" % (nodeTypenameForSimulink, memberNumber)
        g_dataviewAsnMatLabFile.write("%s=Simulink.BusElement;\n" % busMemberName)
        g_dataviewAsnMatLabFile.write("%s.Name='choiceIdx';\n" % busMemberName)
        g_dataviewAsnMatLabFile.write("%s.DataType='uint8';\n" % busMemberName)
        g_dataviewAsnMatLabFile.write("%s.Dimensions=1;\n\n" % busMemberName)

        g_definitionOfTypesCHeaderFile.write("    int choiceIdx;\n\n")

    for member in node._members:
        memberNumber += 1

        memberName = member[0]
        memberNode = member[1]

        busMemberName = "%s_member%02d" % (nodeTypenameForSimulink, memberNumber)
        g_dataviewAsnMatLabFile.write("%s=Simulink.BusElement;\n" % busMemberName)
        g_dataviewAsnMatLabFile.write("%s.Name='%s';\n" % (busMemberName, CleanNameAsSimulinkWants(memberName)))

        while isinstance(memberNode, AsnMetaMember):
            memberNode = astLookupDict[memberNode._containedType]

        if isinstance(memberNode, AsnBool):
            dataTypeMatLab = 'boolean'
            dataTypeC = 'flag'

        elif isinstance(memberNode, AsnInt):
            dataTypeMatLab = MapIntegerForMatLab(memberNode)
            dataTypeC = MapIntegerForC(memberNode)

        elif isinstance(memberNode, AsnReal):
            dataTypeMatLab = 'double'
            dataTypeC = 'asn1Real'

        elif isinstance(memberNode, (AsnAsciiString, AsnOctetString)):
            if isinstance(member[1], AsnMetaMember):
                dataTypeMatLab = CleanNameAsSimulinkWants(member[1]._containedType)
            else:  # pragma: no cover
                dataTypeMatLab = member[1]._pseudoname

            dataTypeC = dataTypeMatLab

        elif isinstance(memberNode, AsnEnumerated):
            dataTypeMatLab = 'Enum: %s' % CleanNameAsSimulinkWants(member[1]._containedType)
            dataTypeC = 'asn1Scc%s' % CleanNameAsSimulinkWants(member[1]._containedType)

        elif isinstance(memberNode, (AsnSequence, AsnChoice, AsnSequenceOf)):
            dataTypeMatLab = CleanNameAsSimulinkWants(member[1]._containedType)
            dataTypeC = dataTypeMatLab

        else:
            panic("QGenC_A_mapper: Unhandled category of sequence member (%s)" % str(member[1]))  # pragma: no cover

        g_dataviewAsnMatLabFile.write("%s.DataType='%s';\n" % (busMemberName, dataTypeMatLab))
        g_dataviewAsnMatLabFile.write("%s.Dimensions=1;\n\n" % busMemberName)

        if isSequenceUsingAsciiStringOrChoice or isChoice:
            g_definitionOfTypesCHeaderFile.write('    %s %s;\n' % (dataTypeC, CleanNameAsSimulinkWants(memberName)))

    if isSequenceUsingAsciiStringOrChoice or isChoice:
        g_definitionOfTypesCHeaderFile.write('} %s;\n\n' % nodeTypenameForSimulink)

    g_dataviewAsnMatLabFile.write("%s = Simulink.Bus;\n" % nodeTypenameForSimulink)
    g_dataviewAsnMatLabFile.write("%s.HeaderFile = 'simulink_definition_of_types.h';\n" % nodeTypenameForSimulink)
    g_dataviewAsnMatLabFile.write("%s.Elements = [" % nodeTypenameForSimulink)

    for i in range(0, memberNumber):
        g_dataviewAsnMatLabFile.write("%s_member%02d " % (nodeTypenameForSimulink, i + 1))

    g_dataviewAsnMatLabFile.write("];\n\n")


def ProcessSequenceOf(node: AsnSequenceOf, nodeTypename: str, nodeTypenameForSimulink: str, astLookupDict: AST_Lookup) -> None:
    # pylint: disable=unused-argument

    contained = node._containedType
    containedNode = astLookupDict[node._containedType]

    if isinstance(containedNode, AsnBool):
        CreateMatLabBusTypeWithArrAndNCountElems(node, nodeTypenameForSimulink, 'boolean', True)
        CreateCDirectDefine(nodeTypenameForSimulink)

    elif isinstance(containedNode, AsnInt):
        CreateMatLabBusTypeWithArrAndNCountElems(node, nodeTypenameForSimulink, MapIntegerForMatLab(containedNode), True)
        CreateCDirectDefine(nodeTypenameForSimulink)

    elif isinstance(containedNode, AsnReal):
        CreateMatLabBusTypeWithArrAndNCountElems(node, nodeTypenameForSimulink, 'double', True)
        CreateCDirectDefine(nodeTypenameForSimulink)

    elif isinstance(containedNode, AsnAsciiString):
        CreateMatLabBusTypeWithArrAndNCountElems(node, nodeTypenameForSimulink, CleanNameAsSimulinkWants(contained), True)
        CreateCStructTypeSequenceOfDefine(node, contained, nodeTypenameForSimulink)

    elif isinstance(containedNode, AsnOctetString):
        CreateMatLabBusTypeWithArrAndNCountElems(node, nodeTypenameForSimulink, CleanNameAsSimulinkWants(contained), True)
        CreateCDirectDefine(nodeTypenameForSimulink)

    elif isinstance(containedNode, AsnEnumerated):
        CreateMatLabBusTypeWithArrAndNCountElems(node, nodeTypenameForSimulink, 'Enum: ' + CleanNameAsSimulinkWants(contained), True)
        CreateCDirectDefine(nodeTypenameForSimulink)

    elif isinstance(containedNode, AsnSequence):
        CreateMatLabBusTypeWithArrAndNCountElems(node, nodeTypenameForSimulink, CleanNameAsSimulinkWants(contained), True)

        if IsSequenceUsingAsciiStringOrChoice(containedNode, astLookupDict):
            CreateCStructTypeSequenceOfDefine(node, contained, nodeTypenameForSimulink)
        else:
            CreateCDirectDefine(nodeTypenameForSimulink)

    elif isinstance(containedNode, AsnChoice):
        CreateMatLabBusTypeWithArrAndNCountElems(node, nodeTypenameForSimulink, CleanNameAsSimulinkWants(contained), True)
        CreateCStructTypeSequenceOfDefine(node, contained, nodeTypenameForSimulink)

    elif isinstance(containedNode, AsnSequenceOf):
        CreateMatLabBusTypeWithArrAndNCountElems(node, nodeTypenameForSimulink, CleanNameAsSimulinkWants(contained), True)

        sequenceOfBasicType = GetSequenceOfBasicType(node, astLookupDict)

        if isinstance(sequenceOfBasicType, (AsnAsciiString, AsnChoice)):
            CreateCStructTypeSequenceOfDefine(node, contained, nodeTypenameForSimulink)

        elif isinstance(sequenceOfBasicType, AsnSequence):
            if IsSequenceUsingAsciiStringOrChoice(sequenceOfBasicType, astLookupDict):
                CreateCStructTypeSequenceOfDefine(node, contained, nodeTypenameForSimulink)
            else:
                CreateCDirectDefine(nodeTypenameForSimulink)

        else:
            CreateCDirectDefine(nodeTypenameForSimulink)

    else:
        panic("QGenC_A_mapper: Unhandled category of contained type (%s,%s)" % (node.Location(), str(contained)))  # pragma: no cover


def CreateDeclarationForType(nodeTypename: str, astLookupDict: AST_Lookup, astLeafTypesDict: AST_Leaftypes) -> None:
    if nodeTypename in g_definedTypes:
        return

    g_definedTypes.add(nodeTypename)

    results = []  # type: List[str]
    ScanChildren(nodeTypename, astLookupDict[nodeTypename], astLookupDict, results, isRoot=True, createInnerNodesInNames=True)

    inform("Prerequisites of %s", nodeTypename)
    for prereqNodeTypename in results:
        if prereqNodeTypename != '':
            inform("\t%s", prereqNodeTypename)
            CreateDeclarationForType(prereqNodeTypename, astLookupDict, astLeafTypesDict)

    node = astLookupDict[nodeTypename]
    nodeTypenameForSimulink = CleanNameAsSimulinkWants(nodeTypename)

    if isinstance(node, AsnBool):
        ProcessBool(node, nodeTypename, nodeTypenameForSimulink, astLookupDict)

    elif isinstance(node, AsnInt):
        ProcessInt(node, nodeTypename, nodeTypenameForSimulink, astLookupDict)

    elif isinstance(node, AsnReal):
        ProcessReal(node, nodeTypename, nodeTypenameForSimulink, astLookupDict)

    elif isinstance(node, AsnAsciiString):
        ProcessIA5String(node, nodeTypename, nodeTypenameForSimulink, astLookupDict)

    elif isinstance(node, AsnOctetString):
        ProcessOctetString(node, nodeTypename, nodeTypenameForSimulink, astLookupDict)

    elif isinstance(node, AsnEnumerated):
        ProcessEnum(node, nodeTypename, nodeTypenameForSimulink, astLookupDict)

    elif isinstance(node, (AsnSequence, AsnChoice)):
        ProcessSequenceChoice(node, nodeTypename, nodeTypenameForSimulink, astLookupDict)

    elif isinstance(node, AsnSequenceOf):
        ProcessSequenceOf(node, nodeTypename, nodeTypenameForSimulink, astLookupDict)

    else:
        panic("Unhandled ASN.1 type : %s" % nodeTypename)  # pragma: no cover


def CreateDeclarationsForAllTypes(astLookupDict: AST_Lookup, astLeafTypesDict: AST_Leaftypes) -> None:
    for nodeTypename in list(astLookupDict.keys()):
        CreateDeclarationForType(nodeTypename, astLookupDict, astLeafTypesDict)
